"""
This file was created by Sebastian Gruenwald on 14.11.2024, Neuhausen am Rheinfall.

Contact:
  - Email: sebiscodes@gmail.com

Social Links:
  - GitHub: https://github.com/sebiscodes
  - Instagram: https://www.instagram.com/sebisprojects/
  - YouTube: https://www.youtube.com/@sebisprojects
  - Linktree: https://linktr.ee/sebisprojects

Note: Comments were generated by ChatGPT
"""

class SHLSDecoder:
    """
    SHLSDecoder is a utility class for decoding SHLS-formatted strings into structured data.

    This class processes hierarchical data based on indentation levels, generates templates for the structure,
    and extracts data accordingly. It supports complex nested structures.
    """

    def __init__(self):
        """
        Initializes the SHLSDecoder with default indentation settings.
        """
        self.__indentation = ' '  # Defines a single space as one indentation level
        self.__intends_per_level = ""  # Stores the determined number of spaces per level

    def decode(self, shls_string):
        """
        Decodes an SHLS-formatted string into a structured dictionary.

        - Splits the input string into lines.
        - Identifies top-level keys and creates or uses templates to extract data.
        - Handles nested data structures recursively.

        Args:
            shls_string (str): The SHLS-formatted string to decode.

        Returns:
            dict: A dictionary containing the decoded data.
        """
        self.__lines = shls_string.strip().splitlines()  # Split the input string into lines
        self.__data = {}  # Stores the extracted data
        self.__templates = {}  # Stores the templates for each top-level key
        top_level_key = ""

        # Process each line in the SHLS input
        while self.__lines:
            line = self.__get_line(pop=True)  # Get the current line and remove it from the list
            level = self.__get_level(line)  # Determine the indentation level of the line
            value = self.__get_value(line)  # Extract the actual content of the line

            # If it's a new top-level key, store it
            if level == 0 and value != "":
                top_level_key = value

            if top_level_key != "":
                next_level, next_is_empty = self.__get_next_level()
                if next_level > 0 and not next_is_empty:
                    # If the template doesn't exist, create it
                    if top_level_key not in self.__templates:
                        self.__templates[top_level_key], line = self.__get_template()
                        value = self.__get_value(line)
                        next_level, next_is_empty = self.__get_next_level()
                        # If this is a block end, populate data for the top-level key
                        if next_level == self.__intends_per_level and value == "":
                            self.__data[top_level_key] = self.__get_data(self.__templates[top_level_key])
                    else:
                        # Populate data using the existing template
                        self.__data[top_level_key] = self.__get_data(self.__templates[top_level_key])
        return self.__data

    def __get_line(self, pop):
        """
        Retrieves the current line from the SHLS string and optionally removes it.

        Args:
            pop (bool): If True, the current line is removed from the list.

        Returns:
            str: The current line, or an empty string if no lines remain.
        """
        if self.__lines:
            line = self.__lines[0]
            if pop:
                self.__lines.pop(0)  # Remove the line if pop is True
            return line
        return ""

    def __get_level(self, line):
        """
        Calculates the indentation level of the given line.

        - The level is determined by the number of spaces before the content.
        - If the indentation width per level is not set, it initializes it.

        Args:
            line (str): The line to analyze.

        Returns:
            int: The indentation level of the line.
        """
        level = len(line) - len(line.lstrip(self.__indentation))
        if not self.__intends_per_level:
            self.__intends_per_level = level  # Set the indentation width if unset
        return level

    def __get_value(self, line):
        """
        Extracts the trimmed content of a line.

        Args:
            line (str): The line to process.

        Returns:
            str: The trimmed content of the line.
        """
        return line.strip()

    def __get_next_level(self):
        """
        Determines the indentation level and whether the next line is empty.

        Returns:
            tuple: A tuple containing:
                - The level of the next line.
                - A boolean indicating whether the next line is empty.
        """
        line = self.__get_line(pop=False)  # Peek at the next line without removing it
        return self.__get_level(line), self.__get_value(line) == ""  # Return its level and emptiness status

    def __get_template(self):
        """
        Recursively generates a template structure based on indentation levels.

        - Keys are indexed based on their order of appearance.
        - Nested structures are handled recursively.

        Returns:
            tuple: A tuple containing:
                - dict: The generated template structure.
                - str: The last processed line.
        """
        last_value = ""
        line = self.__get_line(pop=False)
        while self.__get_value(line) == "":
            line = self.__get_line(pop=True)  # Skip empty lines
        base_level = self.__get_level(line)  # Determine the base level for this template
        counter = 0
        current_template = {}

        # Build the template recursively
        while self.__lines:
            line = self.__get_line(pop=True)
            value = self.__get_value(line)
            level = self.__get_level(line)

            if value != "":
                # Add the value to the template at the current level
                if level == base_level:
                    current_template[f"{counter}"] = value
                    counter += 1
                    last_value = value

            # Handle nested structures
            next_level, next_is_empty = self.__get_next_level()
            if next_level > base_level:
                current_template[last_value], line = self.__get_template()
                value = self.__get_value(line)
                next_level, next_is_empty = self.__get_next_level()
            if next_level < base_level and not next_is_empty:
                break  # Stop processing if the level decreases
            if next_level == self.__intends_per_level and base_level == self.__intends_per_level and value == "":
                break  # Stop processing on block end
        return current_template.copy(), line

    def __get_data(self, template):
        """
        Recursively fills data based on the template structure.

        - Processes each line and maps its value to the corresponding template key.
        - Handles nested data structures recursively.

        Args:
            template (dict): The template structure to use for data extraction.

        Returns:
            list: A list of dictionaries containing the extracted data.
        """
        line = self.__get_line(pop=False)
        while self.__get_value(line) == "":
            line = self.__get_line(pop=True)  # Skip empty lines
        base_level = self.__get_level(line)  # Determine the base level for this data block
        counter = 0
        data = []  # Store the extracted data
        subdata = {}  # Temporary storage for the current sub-block

        # Extract data recursively
        while self.__lines:
            line = self.__get_line(pop=True)
            value = self.__get_value(line)
            level = self.__get_level(line)

            if value != "":
                # Map the value to the corresponding template key
                if level == base_level:
                    if f"{counter}" in template:
                        key = template[f"{counter}"]
                        if key in template:
                            subdata[key] = self.__get_data(template[key])
                        else:
                            subdata[key] = value
                    counter += 1

            # Handle completed sub-blocks
            if not f"{counter}" in template:
                counter = 0
                data.append(subdata.copy())
                subdata.clear()

            next_level, next_is_empty = self.__get_next_level()
            if next_level < base_level and not next_is_empty:
                break  # Stop processing if the level decreases

        return data.copy()
